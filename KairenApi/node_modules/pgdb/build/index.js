module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// ORM criticism
	// https://web.archive.org/web/20121020042747/http://blog.objectmentor.com/articles/2007/11/02/active-record-vs-objects
	// http://programmers.stackexchange.com/questions/119352/does-the-activerecord-pattern-follow-encourage-the-solid-design-principles
	"use strict";
	
	var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) {
	            try {
	                step(generator.next(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function rejected(value) {
	            try {
	                step(generator.throw(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function step(result) {
	            result.done ? resolve(result.value) : new P(function (resolve) {
	                resolve(result.value);
	            }).then(fulfilled, rejected);
	        }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	// LINQ might be an interesting model to study.
	/*
	
	+ upsert?
	  + http://stackoverflow.com/questions/17267417/how-do-i-do-an-upsert-merge-insert-on-duplicate-update-in-postgresql
	  + http://www.postgresql.org/docs/9.5/static/sql-insert.html
	+ non-emuerating uuid?
	  + uuid v1 might have better performance characteristics. it's time-based sequence, and as such won't cause table fragmentation.
	
	*/
	/*
	using iterator to model relationship is pretty interesting...
	
	var q =
	   from c in db.Customers
	   from o in c.Orders
	   where c.City == "London"
	   select new { c, o };
	*/
	const knex = __webpack_require__(1);
	const upsertMonkeyPatch_1 = __webpack_require__(2);
	function connect(config) {
	    if (exports.db) {
	        return;
	    }
	    console.log("db:", config.connection);
	    // TODO: doesn't seem to be a way to know whether the connection succeed?
	    exports.db = knex(Object.assign({ client: "pg" }, config));
	    upsertMonkeyPatch_1.default(exports.db);
	    // Same as {debug: true}
	    // db.on("query",(obj) => {
	    //   console.log("db query", obj);
	    // });
	    // lame. not what i think it is.
	    // return new Promise<any>(resolve => {
	    //   db.once("start", () => {
	    //     console.log("emit start dammit!");
	    //   });
	    //   db.once("start", resolve);
	    // });
	}
	exports.connect = connect;
	function disconnect() {
	    return __awaiter(this, void 0, Promise, function* () {
	        if (exports.db === undefined) {
	            return;
	        }
	        var err = yield exports.db.destroy();
	        exports.db = undefined;
	        return err;
	    });
	}
	exports.disconnect = disconnect;
	function Table(config) {
	    let tableName = config.tableName;
	    let primaryKey = config.primaryKey;
	    let createTimestamp = config.createTimestamp;
	    let updateTimestamp = config.updateTimestamp;
	
	    if (primaryKey === undefined) {
	        primaryKey = "id";
	    }
	    function timestampCreate(obj) {
	        if (createTimestamp === undefined && updateTimestamp === undefined) {
	            return obj;
	        }
	        const now = new Date();
	        const timestamps = {};
	        if (createTimestamp) {
	            timestamps[createTimestamp] = now;
	        }
	        if (updateTimestamp) {
	            timestamps[updateTimestamp] = now;
	        }
	        return Object.assign(timestamps, obj);
	    }
	    function timestampUpdate(obj) {
	        if (updateTimestamp === undefined) {
	            return obj;
	        }
	        const now = new Date();
	        const timestamps = { [updateTimestamp]: now };
	        return Object.assign(timestamps, obj);
	    }
	    class _Table {
	        all() {
	            return exports.db(tableName);
	        }
	        // get table(): Query<T> {
	        //   return db(tableName);
	        // }
	        where(obj) {
	            return this.all().where(obj);
	        }
	        whereNot(obj) {
	            return this.all().whereNot(obj);
	        }
	        find(id) {
	            return __awaiter(this, void 0, void 0, function* () {
	                return this.all().where({ [primaryKey]: id }).first();
	            });
	        }
	        insertVoid(obj) {
	            return __awaiter(this, void 0, Promise, function* () {
	                const insert = this.all().insert(timestampCreate(obj));
	                yield insert;
	                return;
	            });
	        }
	        insert(obj) {
	            return __awaiter(this, void 0, Promise, function* () {
	                const insert = this.all().insert(timestampCreate(obj)).returning("*");
	                return (yield insert)[0];
	            });
	        }
	        upsert(obj, upsertUniqueColumns) {
	            return __awaiter(this, void 0, Promise, function* () {
	                const insert = this.all().insert(timestampCreate(obj)).onConflict(upsertUniqueColumns, timestampUpdate(obj)).returning("*");
	                return (yield insert)[0];
	            });
	        }
	        update(key, obj) {
	            return __awaiter(this, void 0, Promise, function* () {
	                const update = this._update(key, obj).returning("*");
	                return (yield update)[0];
	            });
	        }
	        updateVoid(key, obj) {
	            return __awaiter(this, void 0, Promise, function* () {
	                yield this._update(key, obj);
	                return;
	            });
	        }
	
	        _update(key, obj) {
	            if (key == null) {
	                throw new Error("Key cannot be null for update");
	            }
	            return this.all().where({ [primaryKey]: key }).limit(1).update(obj);
	        }
	    }
	    return new _Table();
	}
	exports.Table = Table;

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = require("knex");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	const BaseQueryCompiler = __webpack_require__(3);
	function upsertMonkeyPatch(db) {
	    // https://github.com/tgriesser/knex/issues/54#issuecomment-183838939
	    const QueryBuilder = db.client.QueryBuilder;
	    const QueryCompiler = db.client.QueryCompiler;
	    // monkey patch to add onConflict
	    QueryBuilder.prototype.onConflict = function (columns, updates) {
	        // throw error if method is not insert
	        this._single["onConflictUpdate"] = {
	            columns: columns,
	            updates: updates
	        };
	        return this;
	    };
	    const __baseInsert = BaseQueryCompiler.prototype.insert;
	    QueryCompiler.prototype.insert = function insert() {
	        let sql /*:string */ = __baseInsert.call(this);
	        if (this.single.onConflictUpdate) {
	            var _single$onConflictUpd = this.single.onConflictUpdate;
	            const columns = _single$onConflictUpd.columns;
	            const updates = _single$onConflictUpd.updates;
	
	            sql += " on conflict (" + this.formatter.columnize(columns) + ") ";
	            const doUpdate = Object.keys(updates).sort().map(key => {
	                const val = updates[key];
	                return this.formatter.wrap(key) + ' = ' + this.formatter.parameter(val);
	            }).join(", ");
	            sql += " do update set " + doUpdate;
	        }
	        var returning = this.single.returning;
	        if (returning) {
	            sql += ' returning ' + this.formatter.columnize(returning);
	        }
	        return {
	            sql: sql,
	            returning: returning
	        };
	    };
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = upsertMonkeyPatch;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("knex/lib/query/compiler");

/***/ }
/******/ ]);
//# sourceMappingURL=index.js.map